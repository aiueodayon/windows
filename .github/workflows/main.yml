name: Myrtille Cloudflare Tunnel

on:
  workflow_dispatch:

jobs:
  deploy:
    runs-on: windows-latest

    steps:
      - name: üß∞ Setup PowerShell
        shell: pwsh
        run: |
          Write-Host "PowerShell version:" $PSVersionTable.PSVersion
          Write-Host "Windows version:" (Get-ComputerInfo).WindowsProductName

      # --- Download MSI installer from GitHub ---
      - name: üì¶ Download latest Myrtille MSI
        shell: pwsh
        run: |
          $release = Invoke-RestMethod "https://api.github.com/repos/cedrozor/myrtille/releases/latest"
          $asset = $release.assets | Where-Object { $_.name -match "Myrtille_.*Setup\.msi" } | Select-Object -First 1
          if (-not $asset) {
            Write-Error "‚ùå Myrtille MSI not found in release."
            exit 1
          }
          Write-Host "Found MSI: $($asset.name)"
          Invoke-WebRequest $asset.browser_download_url -OutFile Myrtille.msi -UseBasicParsing
          Write-Host "‚úÖ Downloaded Myrtille.msi"

      # --- Extract MSI contents into C:\Myrtille ---
      - name: üìÇ Extract MSI contents
        shell: pwsh
        run: |
          $target = "C:\Myrtille"
          if (Test-Path $target) { Remove-Item -Recurse -Force $target }
          New-Item -ItemType Directory -Path $target | Out-Null

          Start-Process msiexec.exe -ArgumentList '/a', (Resolve-Path Myrtille.msi), '/qn', "TARGETDIR=$target" -Wait
          Write-Host "‚úÖ Extracted to $target"

          # Á¢∫Ë™ç
          Get-ChildItem -Path $target -Recurse -Filter "Myrtille.Web.exe" -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "üìÑ Found:" $_.FullName }

      # --- Run Myrtille (auto-detect install path; robust start logic; parser fixes) ---
      - name: üöÄ Start Myrtille Web + Services
        shell: pwsh
        run: |
          # Define search locations (common install/extract targets)
          $searchPaths = @(
            "C:\Myrtille",
            "C:\Program Files\Myrtille",
            "C:\Program Files (x86)\Myrtille"
          )

          # Find an executable related to Myrtille (prefer Web, then Services, then any Myrtille*.exe)
          $exePath = $null
          foreach ($path in $searchPaths) {
            if (Test-Path $path) {
              $foundWeb = Get-ChildItem -Path $path -Recurse -Filter "Myrtille.Web.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($foundWeb) { $exePath = $foundWeb.FullName; break }

              $foundServices = Get-ChildItem -Path $path -Recurse -Filter "*Services*.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($foundServices) { $exePath = $foundServices.FullName; break }

              $foundAny = Get-ChildItem -Path $path -Recurse -Filter "Myrtille*.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($foundAny) { $exePath = $foundAny.FullName; break }
            }
          }

          # Broader fallback search on C: if nothing found yet (may take time)
          if (-not $exePath) {
            Write-Host "üîé Doing a broader search on C:\\ for Myrtille executables (this may take a bit)..."
            try {
              $foundWeb = Get-ChildItem -Path C:\ -Recurse -Force -Filter "Myrtille.Web.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($foundWeb) { $exePath = $foundWeb.FullName }
            } catch {
              Write-Warning ("‚ö†Ô∏è Broad search for Myrtille.Web.exe encountered an error: {0}" -f $($_))
            }

            if (-not $exePath) {
              try {
                $foundServices = Get-ChildItem -Path C:\ -Recurse -Force -Filter "*Services*.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
                if ($foundServices) { $exePath = $foundServices.FullName }
              } catch {
                Write-Warning ("‚ö†Ô∏è Broad search for *Services*.exe encountered an error: {0}" -f $($_))
              }
            }

            if (-not $exePath) {
              try {
                $foundAny = Get-ChildItem -Path C:\ -Recurse -Force -Filter "Myrtille*.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
                if ($foundAny) { $exePath = $foundAny.FullName }
              } catch {
                Write-Warning ("‚ö†Ô∏è Broad search for Myrtille*.exe encountered an error: {0}" -f $($_))
              }
            }
          }

          if ($exePath) {
            $base = Split-Path $exePath
            Write-Host "‚úÖ Myrtille executable found at: $exePath (base: $base)"
            # Change to the directory so relative starts work if needed
            Push-Location $base

            # Start any Services-like executables first (e.g., Myrtille.Services.exe or Myrtille.Admin.Services.exe)
            $serviceCandidates = Get-ChildItem -Path $base -Filter "*Services*.exe" -ErrorAction SilentlyContinue
            foreach ($svc in $serviceCandidates) {
              try {
                Write-Host "‚ñ∂ Starting service exe: $($svc.FullName)"
                Start-Process -FilePath $svc.FullName -NoNewWindow -ErrorAction Stop
                Write-Host "üü¢ Started: $($svc.Name)"
              } catch {
                Write-Warning ("‚ö†Ô∏è Failed to start {0}: {1}" -f $($svc.Name), $($_))
              }
            }

            if (-not $serviceCandidates) {
              Write-Host "‚ÑπÔ∏è No *Services*.exe found in $base"
            }

            # Start the Web exe if present (Myrtille.Web.exe or any *Web*.exe)
            $webExe = Get-ChildItem -Path $base -Filter "Myrtille.Web.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
            if (-not $webExe) {
              $webExe = Get-ChildItem -Path $base -Filter "*Web*.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
            }

            if ($webExe) {
              try {
                Write-Host "‚ñ∂ Starting web exe: $($webExe.FullName)"
                Start-Process -FilePath $webExe.FullName -NoNewWindow -ErrorAction Stop
                Write-Host "üü¢ Started: $($webExe.Name) (port 80 expected)"
              } catch {
                Write-Warning ("‚ö†Ô∏è Failed to start {0}: {1}" -f $($webExe.Name), $($_))
              }
            } else {
              # Best-effort: start the originally found exe if it wasn't a services exe and wasn't started yet
              $exeName = Split-Path $exePath -Leaf
              if (-not ($serviceCandidates | Where-Object { $_.Name -eq $exeName })) {
                try {
                  Write-Host "‚ñ∂ Best-effort start of discovered exe: $exePath"
                  Start-Process -FilePath $exePath -NoNewWindow -ErrorAction Stop
                  Write-Host "üü° Started (best-effort): $exeName"
                } catch {
                  Write-Warning ("‚ö†Ô∏è Failed to start discovered exe {0}: {1}" -f $exeName, $($_))
                }
              }
            }

            Start-Sleep -Seconds 5
            Write-Host "‚úÖ Myrtille processes running (if any):"
            Get-Process | Where-Object { $_.ProcessName -match "Myrtille" } | Select-Object ProcessName, Id

            Pop-Location
          } else {
            # Do NOT exit with failure ‚Äî log warning and continue so workflow can proceed to cloudflared
            Write-Warning "‚ö†Ô∏è Myrtille executable not found in common and broad locations. Skipping Myrtille start to avoid failing the workflow."
            Write-Host "You can inspect the runner to see where files extracted to, or adjust TARGETDIR/installer options if needed."

            if (Test-Path "C:\Myrtille") {
              Write-Host "Contents of C:\Myrtille (top 50 entries):"
              Get-ChildItem -Path "C:\Myrtille" -Recurse -Depth 2 -ErrorAction SilentlyContinue | Select-Object -First 50 | ForEach-Object { Write-Host $_.FullName }
            }
          }

      # --- Cloudflared setup ---
      - name: üåê Download Cloudflared
        shell: pwsh
        run: |
          Invoke-WebRequest https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-windows-amd64.exe -OutFile cloudflared.exe
          Write-Host "‚úÖ Cloudflared downloaded."

      - name: ‚òÅÔ∏è Start Cloudflare Tunnel
        shell: pwsh
        env:
          CLOUDFLARED_TOKEN: ${{ secrets.CLOUDFLARED_TOKEN }}
        run: |
          if (-not $env:CLOUDFLARED_TOKEN) {
            Write-Error "‚ùå CLOUDFLARED_TOKEN secret not set. Add it in your repository settings."
            exit 1
          }

          Write-Host "Installing Cloudflared service..."
          .\cloudflared.exe service install $env:CLOUDFLARED_TOKEN

          Write-Host "‚úÖ Cloudflared service installed."
          Start-Sleep -Seconds 8

          Write-Host "‚ö° Checking Cloudflared process..."
          Get-Process | Where-Object { $_.ProcessName -match "cloudflared" } | Select-Object ProcessName, Id


      - name: ‚è≥ Keep job alive for RDP (5 hours)
        shell: pwsh
        run: |
          # 300 minutes = 5 hours
          $minutes = 300
          Write-Host "Keeping job alive for $minutes minutes so you can RDP/connect via Myrtille/cloudflared..."
          for ($i = 0; $i -lt $minutes; $i++) {
            Write-Host "$(Get-Date -Format 's') - keepalive: minute $($i + 1)/$minutes"
            Start-Sleep -Seconds 60
          }
          Write-Host "Keepalive finished."
          

      - name: ‚úÖ Done
        shell: pwsh
        run: |
          Write-Host "üéâ Myrtille + Cloudflare tunnel setup complete!"
