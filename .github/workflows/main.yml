name: Myrtille Cloudflare Tunnel

on:
  workflow_dispatch:

jobs:
  deploy:
    runs-on: windows-latest

    steps:
      - name: üß∞ Setup PowerShell
        shell: pwsh
        run: |
          Write-Host "PowerShell version:" $PSVersionTable.PSVersion
          Write-Host "Windows version:" (Get-ComputerInfo).WindowsProductName

      # --- Download MSI installer from GitHub ---
      - name: üì¶ Download latest Myrtille MSI
        shell: pwsh
        run: |
          $release = Invoke-RestMethod "https://api.github.com/repos/cedrozor/myrtille/releases/latest"
          $asset = $release.assets | Where-Object { $_.name -match "Myrtille_.*Setup\.msi" } | Select-Object -First 1
          if (-not $asset) {
            Write-Error "‚ùå Myrtille MSI not found in release."
            exit 1
          }
          Write-Host "Found MSI: $($asset.name)"
          Invoke-WebRequest $asset.browser_download_url -OutFile Myrtille.msi -UseBasicParsing
          Write-Host "‚úÖ Downloaded Myrtille.msi"

      # --- Extract MSI contents into C:\Myrtille ---
      - name: üìÇ Extract MSI contents
        shell: pwsh
        run: |
          $target = "C:\Myrtille"
          if (Test-Path $target) { Remove-Item -Recurse -Force $target }
          New-Item -ItemType Directory -Path $target | Out-Null

          Start-Process msiexec.exe -ArgumentList '/a', (Resolve-Path Myrtille.msi), '/qn', "TARGETDIR=$target" -Wait
          Write-Host "‚úÖ Extracted to $target"

          # Á¢∫Ë™ç
          Get-ChildItem -Path $target -Recurse -Filter "Myrtille.Web.exe" -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "üìÑ Found:" $_.FullName }

      # --- Run Myrtille (auto-detect install path; improved search & fallback) ---
      - name: üöÄ Start Myrtille Web + Services
        shell: pwsh
        run: |
          # Define search locations (common install/extract targets)
          $searchPaths = @(
            "C:\Myrtille",
            "C:\Program Files\Myrtille",
            "C:\Program Files (x86)\Myrtille"
          )

          # First try: quick search in known locations
          $exePath = $null
          foreach ($path in $searchPaths) {
            if (Test-Path $path) {
              $found = Get-ChildItem -Path $path -Recurse -Filter "Myrtille.Web.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($found) {
                $exePath = $found.FullName
                break
              }
            }
          }

          # Second try: look for any Myrtille*.exe (sometimes names differ) in known locations
          if (-not $exePath) {
            foreach ($path in $searchPaths) {
              if (Test-Path $path) {
                $foundAny = Get-ChildItem -Path $path -Recurse -Filter "Myrtille*.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
                if ($foundAny) {
                  $exePath = $foundAny.FullName
                  break
                }
              }
            }
          }

          # Third try: broader search across C: (may take some time). Limit to first match.
          if (-not $exePath) {
            Write-Host "üîé Doing a broader search on C:\\ for Myrtille executables (this may take a bit)..."
            try {
              # Search for the exact web exe first
              $found = Get-ChildItem -Path C:\ -Recurse -Force -Filter "Myrtille.Web.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($found) { $exePath = $found.FullName }
            } catch {
              Write-Warning "‚ö†Ô∏è Broad search for Myrtille.Web.exe encountered an error: $_"
            }
          }

          if (-not $exePath) {
            try {
              # If exact web exe wasn't found, try any Myrtille*.exe across C:
              $foundAny = Get-ChildItem -Path C:\ -Recurse -Force -Filter "Myrtille*.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($foundAny) { $exePath = $foundAny.FullName }
            } catch {
              Write-Warning "‚ö†Ô∏è Broad search for Myrtille*.exe encountered an error: $_"
            }
          }

          if ($exePath) {
            $base = Split-Path $exePath
            Write-Host "‚úÖ Myrtille executable found at: $exePath (base: $base)"
            cd $base

            if (Test-Path "Myrtille.Services.exe") {
              Start-Process -FilePath "Myrtille.Services.exe" -NoNewWindow
              Write-Host "üü¢ Started Myrtille.Services.exe"
            } else {
              Write-Warning "‚ö†Ô∏è Myrtille.Services.exe not found (may not be needed)"
            }

            # If found executable is the Web exe use it; if not, try to start any suitable exe
            $webExe = Get-ChildItem -Path $base -Filter "Myrtille.Web.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
            if ($webExe) {
              Start-Process -FilePath $webExe.Name -NoNewWindow
              Write-Host "üü¢ Myrtille.Web.exe started (port 80 expected)"
            } else {
              # Start the found exe (best-effort) if it's not the Web exe
              Start-Process -FilePath (Split-Path $exePath -Leaf) -NoNewWindow
              Write-Host "üü° Started $([System.IO.Path]::GetFileName($exePath)) (best-effort)"
            }

            Start-Sleep -Seconds 5
            Write-Host "‚úÖ Myrtille processes running (if any):"
            Get-Process | Where-Object { $_.ProcessName -match "Myrtille" } | Select-Object ProcessName, Id
          } else {
            # Do NOT exit with failure ‚Äî log warning and continue so workflow can proceed to cloudflared
            Write-Warning "‚ö†Ô∏è Myrtille executable not found in common and broad locations. Skipping Myrtille start to avoid failing the workflow."
            Write-Host "You can inspect the runner to see where files extracted to, or adjust TARGETDIR/installer options if needed."
            # List top-level extracted folders for debugging
            if (Test-Path "C:\Myrtille") {
              Write-Host "Contents of C:\Myrtille (top 50 entries):"
              Get-ChildItem -Path "C:\Myrtille" -Recurse -Depth 2 -ErrorAction SilentlyContinue | Select-Object -First 50 | ForEach-Object { Write-Host $_.FullName }
            }
          }

      # --- Cloudflared setup ---
      - name: üåê Download Cloudflared
        shell: pwsh
        run: |
          Invoke-WebRequest https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-windows-amd64.exe -OutFile cloudflared.exe
          Write-Host "‚úÖ Cloudflared downloaded."

      - name: ‚òÅÔ∏è Start Cloudflare Tunnel
        shell: pwsh
        env:
          CLOUDFLARED_TOKEN: ${{ secrets.CLOUDFLARED_TOKEN }}
        run: |
          if (-not $env:CLOUDFLARED_TOKEN) {
            Write-Error "‚ùå CLOUDFLARED_TOKEN secret not set. Add it in your repository settings."
            exit 1
          }

          Write-Host "Installing Cloudflared service..."
          .\cloudflared.exe service install $env:CLOUDFLARED_TOKEN

          Write-Host "‚úÖ Cloudflared service installed."
          Start-Sleep -Seconds 8

          Write-Host "‚ö° Checking Cloudflared process..."
          Get-Process | Where-Object { $_.ProcessName -match "cloudflared" } | Select-Object ProcessName, Id

      - name: ‚úÖ Done
        shell: pwsh
        run: |
          Write-Host "üéâ Myrtille + Cloudflare tunnel setup complete!"
