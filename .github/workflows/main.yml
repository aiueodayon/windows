name: Myrtille Cloudflare Tunnel

on:
  workflow_dispatch:

jobs:
  deploy:
    runs-on: windows-latest
    timeout-minutes: 300

    steps:
      - name: üß∞ Setup PowerShell
        shell: pwsh
        run: |
          Write-Host "PowerShell version:" $PSVersionTable.PSVersion
          Write-Host "Windows version:" (Get-ComputerInfo).WindowsProductName

      - name: üì¶ Download latest Myrtille MSI
        shell: pwsh
        run: |
          $release = Invoke-RestMethod "https://api.github.com/repos/cedrozor/myrtille/releases/latest"
          $asset = $release.assets | Where-Object { $_.name -match "Myrtille_.*Setup\.msi" } | Select-Object -First 1
          if (-not $asset) {
            Write-Error "‚ùå Myrtille MSI not found in release."
            exit 1
          }
          Write-Host "Found MSI: $($asset.name)"
          Invoke-WebRequest $asset.browser_download_url -OutFile Myrtille.msi -UseBasicParsing
          Write-Host "‚úÖ Downloaded Myrtille.msi"

      - name: üìÇ Extract MSI contents
        shell: pwsh
        run: |
          $target = "C:\Myrtille"
          if (Test-Path $target) { Remove-Item -Recurse -Force $target }
          New-Item -ItemType Directory -Path $target | Out-Null

          Start-Process msiexec.exe -ArgumentList '/a', (Resolve-Path Myrtille.msi), '/qn', "TARGETDIR=$target" -Wait
          Write-Host "‚úÖ Extracted to $target"

          Get-ChildItem -Path $target -Recurse -Filter "Myrtille.Web.exe" -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "üìÑ Found:" $_.FullName }

      - name: üöÄ Start Myrtille Web + Services
        shell: pwsh
        run: |
          $searchPaths = @(
            "C:\Myrtille",
            "C:\Program Files\Myrtille",
            "C:\Program Files (x86)\Myrtille"
          )

          $exePath = $null
          foreach ($path in $searchPaths) {
            if (Test-Path $path) {
              $foundWeb = Get-ChildItem -Path $path -Recurse -Filter "Myrtille.Web.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($foundWeb) { $exePath = $foundWeb.FullName; break }

              $foundServices = Get-ChildItem -Path $path -Recurse -Filter "*Services*.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($foundServices) { $exePath = $foundServices.FullName; break }

              $foundAny = Get-ChildItem -Path $path -Recurse -Filter "Myrtille*.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($foundAny) { $exePath = $foundAny.FullName; break }
            }
          }

          if (-not $exePath) {
            Write-Host "üîé Doing a broader search on C:\ for Myrtille executables (this may take a bit)..."
            try {
              $foundWeb = Get-ChildItem -Path C:\ -Recurse -Force -Filter "Myrtille.Web.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($foundWeb) { $exePath = $foundWeb.FullName }
            } catch {
              Write-Warning ("‚ö†Ô∏è Broad search for Myrtille.Web.exe encountered an error: {0}" -f $($_))
            }

            if (-not $exePath) {
              try {
                $foundServices = Get-ChildItem -Path C:\ -Recurse -Force -Filter "*Services*.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
                if ($foundServices) { $exePath = $foundServices.FullName }
              } catch {
                Write-Warning ("‚ö†Ô∏è Broad search for *Services*.exe encountered an error: {0}" -f $($_))
              }
            }

            if (-not $exePath) {
              try {
                $foundAny = Get-ChildItem -Path C:\ -Recurse -Force -Filter "Myrtille*.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
                if ($foundAny) { $exePath = $foundAny.FullName }
              } catch {
                Write-Warning ("‚ö†Ô∏è Broad search for Myrtille*.exe encountered an error: {0}" -f $($_))
              }
            }
          }

          if ($exePath) {
            $base = Split-Path $exePath
            Write-Host "‚úÖ Myrtille executable found at: $exePath (base: $base)"
            Push-Location $base

            $serviceCandidates = Get-ChildItem -Path $base -Filter "*Services*.exe" -ErrorAction SilentlyContinue
            foreach ($svc in $serviceCandidates) {
              try {
                Write-Host "‚ñ∂ Starting service exe: $($svc.FullName)"
                Start-Process -FilePath $svc.FullName -NoNewWindow -ErrorAction Stop
                Write-Host "üü¢ Started: $($svc.Name)"
              } catch {
                Write-Warning ("‚ö†Ô∏è Failed to start {0}: {1}" -f $($svc.Name), $($_))
              }
            }

            if (-not $serviceCandidates) {
              Write-Host "‚ÑπÔ∏è No *Services*.exe found in $base"
            }

            $webExe = Get-ChildItem -Path $base -Filter "Myrtille.Web.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
            if (-not $webExe) {
              $webExe = Get-ChildItem -Path $base -Filter "*Web*.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
            }

            if ($webExe) {
              try {
                Write-Host "‚ñ∂ Starting web exe: $($webExe.FullName)"
                Start-Process -FilePath $webExe.FullName -NoNewWindow -ErrorAction Stop
                Write-Host "üü¢ Started: $($webExe.Name) (port 80 expected)"
              } catch {
                Write-Warning ("‚ö†Ô∏è Failed to start {0}: {1}" -f $($webExe.Name), $($_))
              }
            } else {
              $exeName = Split-Path $exePath -Leaf
              if (-not ($serviceCandidates | Where-Object { $_.Name -eq $exeName })) {
                try {
                  Write-Host "‚ñ∂ Best-effort start of discovered exe: $exePath"
                  Start-Process -FilePath $exePath -NoNewWindow -ErrorAction Stop
                  Write-Host "üü° Started (best-effort): $exeName"
                } catch {
                  Write-Warning ("‚ö†Ô∏è Failed to start discovered exe {0}: {1}" -f $exeName, $($_))
                }
              }
            }

            Start-Sleep -Seconds 5
            Write-Host "‚úÖ Myrtille processes running (if any):"
            Get-Process | Where-Object { $_.ProcessName -match "Myrtille" } | Select-Object ProcessName, Id

            Pop-Location
          } else {
            Write-Warning "‚ö†Ô∏è Myrtille executable not found in common and broad locations. Skipping Myrtille start to avoid failing the workflow."
            Write-Host "You can inspect the runner to see where files extracted to, or adjust TARGETDIR/installer options if needed."
            if (Test-Path "C:\Myrtille") {
              Write-Host "Contents of C:\Myrtille (top 50 entries):"
              Get-ChildItem -Path "C:\Myrtille" -Recurse -Depth 2 -ErrorAction SilentlyContinue | Select-Object -First 50 | ForEach-Object { Write-Host $_.FullName }
            }
          }

      - name: üåê Download Cloudflared
        shell: pwsh
        run: |
          Invoke-WebRequest https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-windows-amd64.exe -OutFile cloudflared.exe
          Write-Host "‚úÖ Cloudflared downloaded."

      - name: ‚òÅÔ∏è Install Cloudflared service (if token provided)
        shell: pwsh
        env:
          CLOUDFLARED_TOKEN: ${{ secrets.CLOUDFLARED_TOKEN }}
        run: |
          if ($env:CLOUDFLARED_TOKEN) {
            Write-Host "Installing cloudflared service (token provided)..."
            .\cloudflared.exe service install $env:CLOUDFLARED_TOKEN
            Write-Host "‚úÖ Cloudflared service installed."
            Start-Sleep -Seconds 3
          } else {
            Write-Host "No CLOUDFLARED_TOKEN provided; skipping service install."
          }

      - name: ‚òÅÔ∏è Start ephemeral Cloudflared tunnel and print public URL
        shell: pwsh
        run: |
          # Start an ephemeral tunnel (background) so we can capture the public URL to logs.
          # The tunnel process will keep running while the job stays alive.
          $outFile = "$PSScriptRoot\cloudflared.out"
          $errFile = "$PSScriptRoot\cloudflared.err"
          if (Test-Path $outFile) { Remove-Item $outFile -Force }
          if (Test-Path $errFile) { Remove-Item $errFile -Force }

          Write-Host "Starting ephemeral cloudflared tunnel (will print an ephemeral public URL)..."
          $args = @("tunnel", "--url", "http://localhost:80", "--no-autoupdate")
          # Start-Process with redirection so output can be read from file
          $proc = Start-Process -FilePath ".\cloudflared.exe" -ArgumentList $args -RedirectStandardOutput $outFile -RedirectStandardError $errFile -PassThru

          Write-Host "cloudflared started (PID: $($proc.Id)). Waiting up to 15 seconds for the public URL to appear in the log..."
          $attempts = 15
          $url = $null
          for ($i = 0; $i -lt $attempts; $i++) {
            Start-Sleep -Seconds 1
            if (Test-Path $outFile) {
              $text = Get-Content $outFile -Raw -ErrorAction SilentlyContinue
              if ($text) {
                # try to find an https URL (trycloudflare or custom)
                $m = [regex]::Match($text, "(https?://[^\s'\"<>]+)")
                if ($m.Success) { $url = $m.Value; break }
              }
            }
          }

          if ($url) {
            Write-Host "üîó Public URL for Myrtille (ephemeral): $url"
            Write-Host "Open that URL in your browser and use the Myrtille web UI to start an RDP session."
          } else {
            Write-Warning "‚ö†Ô∏è Could not find public URL in cloudflared output within timeout."
            Write-Host "---- cloudflared stdout (tail):"
            if (Test-Path $outFile) { Get-Content $outFile -Tail 50 | ForEach-Object { Write-Host $_ } } else { Write-Host "(no stdout yet)" }
            Write-Host "---- cloudflared stderr (tail):"
            if (Test-Path $errFile) { Get-Content $errFile -Tail 50 | ForEach-Object { Write-Host $_ } } else { Write-Host "(no stderr yet)" }
          }

          Write-Host "Note: The ephemeral tunnel process will remain running in the background while the job is alive."

      - name: ‚è≥ Keep job alive for RDP (5 hours)
        shell: pwsh
        run: |
          # 300 minutes = 5 hours
          $minutes = 300
          Write-Host "Keeping job alive for $minutes minutes so you can RDP/connect via Myrtille/cloudflared..."
          for ($i = 0; $i -lt $minutes; $i++) {
            Write-Host "$(Get-Date -Format 's') - keepalive: minute $($i + 1)/$minutes"
            Start-Sleep -Seconds 60
          }
          Write-Host "Keepalive finished."

      - name: ‚úÖ Done
        shell: pwsh
        run: |
          Write-Host "üéâ Myrtille + Cloudflare tunnel setup complete!"
